#version 400
#include "EngineData/glsl/common.glfs"

//-----------------------------------------------------------------------------
layout (location = 0) out vec4 outColor;
layout (location = 1) out vec4 outBright;


//-----------------------------------------------------------------------------
uniform sampler2D NormalTex;
uniform sampler2D AlbedoSpecularTex;
uniform sampler2D DepthTex;
uniform sampler2D ShadowMapTex;
uniform float BrightThreshold;
uniform mat4 ProjectionMatrix;
uniform mat4 InvViewMatrix;
uniform mat4 LightSpaceMatrix;
uniform vec3 ViewPos;


//-----------------------------------------------------------------------------
const int MAX_LIGHTS = 32;
struct Light
{
    vec3 Position;
    vec3 Color;

    float Intensity;
    float Linear;
    float Quadratic;
};
uniform int LightCount;
uniform Light lights[MAX_LIGHTS];


//-----------------------------------------------------------------------------
in vec2 TexCoord;
in vec2 ViewRay;


//-----------------------------------------------------------------------------
vec2 poissonDisk[16] = vec2[]( 
   vec2( -0.94201624, -0.39906216 ), 
   vec2( 0.94558609, -0.76890725 ), 
   vec2( -0.094184101, -0.92938870 ), 
   vec2( 0.34495938, 0.29387760 ), 
   vec2( -0.91588581, 0.45771432 ), 
   vec2( -0.81544232, -0.87912464 ), 
   vec2( -0.38277543, 0.27676845 ), 
   vec2( 0.97484398, 0.75648379 ), 
   vec2( 0.44323325, -0.97511554 ), 
   vec2( 0.53742981, -0.47373420 ), 
   vec2( -0.26496911, -0.41893023 ), 
   vec2( 0.79197514, 0.19090188 ), 
   vec2( -0.24188840, 0.99706507 ), 
   vec2( -0.81409955, 0.91437590 ), 
   vec2( 0.19984126, 0.78641367 ), 
   vec2( 0.14383161, -0.14100790 ) 
);


//-----------------------------------------------------------------------------
float random(vec3 seed, int i)
{
	vec4 seed4 = vec4(seed, i);
	float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
	return fract(sin(dot_product) * 43758.5453);
}


//-----------------------------------------------------------------------------
float computeShadow(sampler2D shadow_map, vec4 frag_pos_light_space, vec3 normal, vec3 light_dir)
{
    vec3 proj_coord = frag_pos_light_space.xyz / frag_pos_light_space.w;
    proj_coord = proj_coord * 0.5 + 0.5;
    if (proj_coord.z >= 1) return 0;
    float closet_depth = texture(shadow_map, proj_coord.xy).r;
    float cur_dpeth = proj_coord.z;
    float bias = max(0.0 * (1.0 - dot(normal, light_dir)), 0.001);
    float shadow = 0;
    vec2 texel_size = 1.0 / textureSize(shadow_map, 0);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            int index = int(16.0 * random(floor(frag_pos_light_space.xyz * 10000.0), x+y)) % 16;
            float pcf_depth = texture(shadow_map, proj_coord.xy + (vec2(x, y) + poissonDisk[index]) * texel_size).r;
            shadow += cur_dpeth - bias > pcf_depth ? 0.9:0.0;
        }
    }
    shadow /= 9;
    return shadow;
}


//-----------------------------------------------------------------------------
void main()
{
    vec3 frag_view_pos = computeFragPosFromDepth(
        ProjectionMatrix, DepthTex, ViewRay, TexCoord);
    vec3 FragPos = (InvViewMatrix * vec4(frag_view_pos, 1)).rgb;
    vec3 Normal = texture(NormalTex, TexCoord).rgb;
    vec3 Diffuse = texture(AlbedoSpecularTex, TexCoord).rgb;
    float Specular = texture(AlbedoSpecularTex, TexCoord).a;

    //Ambient
    vec3 lighting = vec3(0, 0, 0);
    vec3 ambient = Diffuse * 0.1;
    vec3 view_dir = normalize(ViewPos - FragPos);

    for (int i=0;i<LightCount;++i)
    {
        //Diffuse
        vec3 light_dir = normalize(lights[i].Position - FragPos);
        vec3 diffuse = max(dot(Normal, light_dir), 0.0) * Diffuse * lights[i].Color;

        //Specular
        vec3 half_way_dir = normalize(light_dir + view_dir);
        float specular_intensity = pow(max(dot(Normal, half_way_dir), 0.0), 16);
        vec3 specular = lights[i].Color * specular_intensity * Specular;

        //Attenuation
        float distance = length(lights[i].Position - FragPos);
        float attenuation = 1.0 / (1.0 + lights[i].Linear * distance + lights[i].Quadratic * distance * distance);

        //Sumation lighting
        lighting += (diffuse + specular) * lights[i].Intensity * attenuation;
    }

    vec4 FragPosLightSpace = LightSpaceMatrix * vec4(FragPos, 1);
    float shadow = computeShadow(ShadowMapTex, FragPosLightSpace, Normal, vec3(0, 0, 1));
    lighting = ambient + lighting * (1.0 - shadow);

    outColor = vec4(lighting, 1.0);

    float brightness = length(outColor.rgb);
    if (brightness > BrightThreshold)
        outBright = vec4(outColor.rgb, 1.0);
    else
        outBright = vec4(0, 0, 0, 1.0);
}
